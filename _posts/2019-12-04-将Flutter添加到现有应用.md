---
title: 将Flutter添加到现有应用
layout: post
category: blog
tag:
- other
---

# 将Flutter添加到现有应用

Jenn Magder编辑了此页面 20天前 · [99个修订](https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps/_history)

## 介绍

轻松将Flutter添加到现有应用程序的工作正在进行中。

该页面记录了该工作的当前状态，并将在我们构建必要的工具时进行更新。

最后更新时间为2019年8月23日。

“添加到应用”支持**处于预览状态**，到目前为止仅在主频道上可用。

## 免责声明

由于Flutter的“添加到应用”功能处于预览状态，因此相关的API和工具不稳定，并且可能会发生变化。

## Flutter模块项目模板

使用创建的Flutter项目`flutter create xxx`包括用于Flutter / Dart代码的非常简单的宿主应用程序（单个Activity Android宿主和单个ViewController iOS宿主）。您可以修改这些主机应用程序以适合您的需求并从那里构建。

但是，如果您要从任一平台的*现有*主机应用程序开始，则可能需要将Flutter项目作为某种形式的库包含在该应用程序中。

这就是Flutter模块模板所提供的。执行将 `flutter create -t module xxx`产生一个Flutter项目，其中包含一个Android库和一个CocoaPods Pod，供您现有的宿主应用程序使用。

## 安卓系统

### 创建Flutter模块

假设您在处已有一个Android应用`some/path/MyApp`，并且您希望Flutter项目作为同级项目：

```sh
$ cd some/path/
$ flutter create -t module --org com.example my_flutter
```

这将创建一个`some/path/my_flutter/`Flutter模块项目，其中包含一些Dart代码以帮助您入门以及一个`.android/`隐藏的子文件夹，该文件夹将模块项目包装在Android库中。

#### 使用Android Studio创建Flutter模块

如果您使用Android Studio创建新的Flutter模块，则可以跳过一些手动编辑步骤。为此，请在Android Studio中打开您的Android应用。使用菜单“文件>新建>新建模块...”创建Flutter模块。

将打开“新模块向导”，并带有一个选项面板。向下滚动以找到Flutter的那些。选择标记为的一个`Flutter Module`。单击可`Next`进入Flutter的新模块向导页面。像填写Flutter模块项目一样填写它们。

该模块创建后，你可以开始编辑您的Android应用使用颤振模块（请参见[使用来自Java代码的颤振模块](https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps#use-the-flutter-module-from-your-java-code)）。

您可能需要更改项目视图才能查看Flutter文件。项目文件选项效果很好。

您可以跳过[使主机应用程序依赖Flutter模块的步骤](https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps#make-the-host-app-depend-on-the-flutter-module)；Android Studio已为您添加了源依赖项。

在此支持中，仍然存在一些故障。使用Android Studio 3.5，每次Gradle同步都会导致Flutter模块的Dart支持被删除。每个Dart文件编辑在顶部都有一个按钮可以重新启用它。对于Android Studio 3.6，这不是问题。但是，在3.6中，Gradle同步报告了虚假错误。应该忽略它。（我们正在尝试找到一种方法来消除它。）

### 主机应用程序要求

在尝试将Flutter模块项目连接到主机Android应用之前，请确保您的主机Android应用在您的应用`build.gradle`文件中的`android { }` 块下声明了以下源兼容性，例如：

```
android {
   // ...
  compileOptions {
    sourceCompatibility 1.8 
    targetCompatibility 1.8
  }
}
```

### 使主机应用程序依赖Flutter模块

有两种方法可以实现此目的：

#### 1.取决于Android存档（AAR）

这会将Flutter库打包为包含AAR和POM工件的通用本地Maven存储库。这使您的团队无需安装Flutter SDK即可构建主机应用程序。然后，您可以从本地或远程存储库中分发工件。

假设您在构建了Flutter模块`some/path/my_flutter`，然后运行：

```sh
$ cd some/path/my_flutter
$ flutter build aar
```

此命令（默认为发布模式）使用以下文件创建[本地存储库](https://docs.gradle.org/current/userguide/repository_types.html#sub:maven_local)：

```
build/host/outputs/repo
└── com
    └── example
        └── my_flutter
            └── flutter_release
                ├── 1.0
                │   ├── flutter_release-1.0.aar
                │   ├── flutter_release-1.0.aar.md5
                │   ├── flutter_release-1.0.aar.sha1
                │   ├── flutter_release-1.0.pom
                │   ├── flutter_release-1.0.pom.md5
                │   └── flutter_release-1.0.pom.sha1
                ├── maven-metadata.xml
                ├── maven-metadata.xml.md5
                └── maven-metadata.xml.sha1
```

要依赖AAR，主机应用必须能够找到这些文件。

为此，请`app/build.gradle`在您的主机应用程序中进行编辑，例如它包括本地存储库和依赖项：

```
// MyApp/app/build.gradle

android {
  // ...
}

repositories {
  maven {
    url 'some/path/my_flutter/build/host/outputs/repo'
    // This is relative to the location of the build.gradle file 
    // if using a relative path. 
  }
}

dependencies {
  // ...
  releaseCompile ('com.example.my_flutter:flutter_release:1.0@aar') {
    transitive = true
  }
}
```

您还可以通过运行`flutter build aar --debug` 然后在宿主应用程序中添加依赖项来构建调试变量：

```
// MyApp/app/build.gradle

dependencies {
  // ...
  debugCompile ('com.example.my_flutter:flutter_debug:1.0@aar') {
    transitive = true
  }
}
```

#### 2.取决于模块的源代码

这将为您的Android项目和Flutter项目启用一个步骤的构建。当同时处理两个部分时，这很方便，但是您的团队必须安装Flutter SDK才能构建主机应用程序。

将Flutter模块作为子项目包含在主机应用程序的中`settings.gradle`：

```ruby
// MyApp/settings.gradle
include ':app'                                     // assumed existing content
setBinding(new Binding([gradle: this]))                                 // new
evaluate(new File(                                                      // new
  settingsDir.parentFile,                                               // new
  'my_flutter/.android/include_flutter.groovy'                          // new
)) 
```

结合和脚本评估允许扑模块`include`本身（如`:flutter`）和模块使用任何插件扑（如`:package_info`， `:video_player`在你的评价方面，等等）`settings.gradle`。

`implementation`从您的应用程序引入对Flutter模块的依赖：

```
// MyApp/app/build.gradle

dependencies {
  implementation project(':flutter')
}
```

### 使用Java代码中的Flutter模块

#### Flutter的新Android嵌入

如果您是来这里寻找Flutter的新Android嵌入信息的，请参阅[专用于新嵌入的页面](https://github.com/flutter/flutter/wiki/Adding-Flutter-to-Android)。

本指南指的是`io.flutter.facade.*`例如下的类的用法`io.flutter.facade.FlutterFragment`。这些类正在被弃用。不推荐使用的`io.flutter.facade.FlutterFragment`将由较新的代替`io.flutter.embedding.android.FlutterFragment`。由于的两个版本`FlutterFragment`都处于技术预览版中，并且两个版本都不是API稳定的，因此我们建议使用[新的FlutterFragment](https://github.com/flutter/flutter/wiki/Experimental:-Add-Flutter-Fragment)。

### 生成并运行您的应用

生成和运行`MyApp`的方式与添加Flutter模块依赖项之前的方式完全相同，通常使用Android Studio。编辑，调试和分析Android代码也是如此。

### 热重启/重新加载和调试Dart代码

正在进行全面的IDE集成以支持与混合应用程序的Flutter / Dart代码一起使用。但是基本原理已经通过Flutter命令行工具和Dart Observatory Web用户界面提供。

连接设备或启动仿真器。然后使Flutter CLI工具监听您的应用程序：

```sh
$ cd some/path/my_flutter
$ flutter attach
Waiting for a connection from Flutter on Nexus 5X...
```

`MyApp`从Android Studio以调试模式启动（或通常采用的任何一种方式）。导航到使用Flutter的应用程序区域。然后回到终端，您应该看到类似于以下内容的输出：

```
Done.
Syncing files to device Nexus 5X...                          5.1s

🔥  To hot reload changes while running, press "r". To hot restart (and rebuild state), press "R".
An Observatory debugger and profiler on Nexus 5X is available at: http://127.0.0.1:59556/
For a more detailed help message, press "h". To quit, press "q".
```

现在，您可以在中编辑Dart代码`my_flutter`，并且可以通过`r`在终端中按来重新加载更改。您也可以将上面的URL粘贴到浏览器中，以使用Dart Observatory设置断点，分析内存保留和其他调试任务。

如果您希望为应用程序指定端口号和/或禁用身份验证代码（不建议使用），则可以使用意图标志来实现，例如

```
--ei observatory-port 12345 --eb disable-service-auth-codes
```

可以通过在[Android Studio中`Launch Flags`](https://developer.android.com/studio/run/rundebugconfig#opening)输入这些内容。

## iOS

### 创建Flutter模块

假设您在处有一个现有的iOS应用`some/path/MyApp`，并且您希望Flutter项目作为同级项目：

```sh
$ cd some/path/
$ flutter create -t module my_flutter
```

这将创建一个`some/path/my_flutter/`Flutter模块项目，其中包含一些Dart代码以帮助您入门以及一个`.ios/`隐藏的子文件夹，该子文件夹包装了包含一些Cocoapods和一个辅助Ruby脚本的模块项目。

### 使主机应用程序依赖Flutter模块

下面的描述假定您现有的iOS应用程序具有与要求Xcode版本10.0使用Objective-C生成新的“单视图应用程序”项目所得到的结构类似的结构。如果您现有的应用程序具有不同的文件夹结构和/或现有`.xcconfig`文件，则可以重用它们，但是可能需要相应地调整下面提到的一些相对路径。

假定的文件夹结构如下：

```
some/path/
  my_flutter/
    lib/main.dart
    .ios/
  MyApp/
    MyApp/
      AppDelegate.h
      AppDelegate.m (or swift)
      :
```

#### 将Flutter应用添加到Podfile

集成Flutter框架需要使用CocoaPods依赖关系管理器。这是因为Flutter框架需要对my_flutter中可能包含的所有Flutter插件可用。

如果您在2019年7月30日之前或之前将Flutter添加到现有的iOS应用程序中， `flutter --version`则`Flutter 1.8.4-pre.21`可能需要 [升级环境](https://github.com/flutter/flutter/wiki/Upgrading-Flutter-added-to-existing-iOS-Xcode-project)。在遵循迁移说明之前，请确保您位于 [主频道上](https://github.com/flutter/flutter/wiki/Flutter-build-release-channels)并可以运行 `flutter upgrade`。

如果需要，请访问[cocoapods.org](https://cocoapods.org/)，了解如何在您的开发计算机上安装CocoaPods。

如果您的宿主应用程序（`MyApp`）已在使用CocoaPods，则只需执行以下操作即可与您的`my_flutter`应用程序集成：

1. 将以下几行添加到您的`Podfile`：

```ruby
  flutter_application_path = 'path/to/my_flutter/'
  load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')
```

1. 对于每个需要嵌入Flutter的Xcode [目标](https://guides.cocoapods.org/syntax/podfile.html#target)，请调用`install_all_flutter_pods(flutter_application_path)`。

```ruby
  target 'MyApp' do
    install_all_flutter_pods(flutter_application_path)
  end
  target 'MyAppTests' do
    install_all_flutter_pods(flutter_application_path)
  end
```

1. 运行`pod install`。

当您更改扑插件的依赖关系`some/path/my_flutter/pubspec.yaml`，你需要运行`flutter pub get`从`some/path/my_flutter`刷新列表插件读取的`podhelper.rb`脚本。然后`pod install`从再次 运行`some/path/MyApp`。

该`podhelper.rb`脚本将确保您的插件Flutter.framework和App.framework嵌入在您的项目中。

现在，您应该可以使用来构建项目`⌘B`。

#### 引擎盖下

如果您出于某种原因手动执行此操作或调试为什么这些步骤无法执行，请执行以下操作：

1. `Flutter.framework`（引擎库）已为您嵌入到您的应用中。这必须与发行版类型（调试/配置文件/发行版）以及应用程序的架构（arm *，x86_64等）相匹配。CocoaPods将其作为供应商框架引入，并确保将其嵌入到本机应用程序中。
2. `App.framework`（您的Flutter应用程序二进制文件）已嵌入到您的应用程序中。CocoaPods还将其作为供应商框架引入，并确保将其嵌入到您的本机应用程序中。
3. 任何插件都将作为CocoaPod Pod添加。从理论上讲，也应该可以手动合并它们，但是这些说明在每个插件的pod依赖项上有所不同。
4. 将构建脚本添加到Podfile目标中，以确保所构建的二进制文件与文件夹中实际存在的Dart代码保持最新。它还使用您的Xcode构建配置（Debug，Profile，Release）来嵌入匹配的发行版类型`Flutter.framework`和`App.framework`。

### 编写代码以从主机应用程序使用FlutterViewController

正确的位置将取决于您的主机应用程序。这是一个由Xcode 10.0生成的宿主应用程序的空白屏幕有意义的示例。

首先，将您的应用程序委托声明为的子类`FlutterAppDelegate`。然后定义FlutterEngine属性，该属性可帮助您注册没有FlutterViewController实例的插件。

在`AppDelegate.h`：

```objective-c
@import UIKit;
@import Flutter;

@interface AppDelegate : FlutterAppDelegate
@property (nonatomic,strong) FlutterEngine *flutterEngine;
@end
```

这可以`AppDelegate.m`非常简单，除非您的主机应用程序需要在此处覆盖其他方法：

```objective-c
@import FlutterPluginRegistrant; // Only if you have Flutter Plugins

#import "AppDelegate.h"

@implementation AppDelegate

// This override can be omitted if you do not have any Flutter Plugins.
- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  self.flutterEngine = [[FlutterEngine alloc] initWithName:@"io.flutter" project:nil];
  [self.flutterEngine runWithEntrypoint:nil];
  [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine];
  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

@end
```

如果您使用Swift编写代码，则可以在以下代码中执行以下操作`AppDelegate.swift`：

```swift
import UIKit
import Flutter
import FlutterPluginRegistrant // Only if you have Flutter Plugins.

@UIApplicationMain
class AppDelegate: FlutterAppDelegate {
  var flutterEngine : FlutterEngine?;
  // Only if you have Flutter plugins.
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    self.flutterEngine = FlutterEngine(name: "io.flutter", project: nil);
    self.flutterEngine?.run(withEntrypoint: nil);
    GeneratedPluginRegistrant.register(with: self.flutterEngine);
    return super.application(application, didFinishLaunchingWithOptions: launchOptions);
  }

}
```

<details style="box-sizing: border-box; display: block; margin-top: 0px; margin-bottom: 16px;"><summary style="box-sizing: border-box; display: list-item; cursor: pointer;"><font style="box-sizing: border-box; vertical-align: inherit;"><font style="box-sizing: border-box; vertical-align: inherit;">如果应用程序委托已经从其他地方继承，该怎么办。</font></font></summary></details>

`ViewController.m`：

```objective-c
#import "AppDelegate.h"
#import "ViewController.h"
@import Flutter;

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
    [button addTarget:self
               action:@selector(handleButtonAction)
     forControlEvents:UIControlEventTouchUpInside];
    [button setTitle:@"Press me" forState:UIControlStateNormal];
    [button setBackgroundColor:[UIColor blueColor]];
    button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0);
    [self.view addSubview:button];
}

- (void)handleButtonAction {
    FlutterEngine *flutterEngine = [(AppDelegate *)[[UIApplication sharedApplication] delegate] flutterEngine];
    FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil];
    [self presentViewController:flutterViewController animated:false completion:nil];
}
@end
```

或者，使用Swift：

`ViewController.swift`：

```swift
import UIKit
import Flutter

class ViewController: UIViewController {
  override func viewDidLoad() {
    super.viewDidLoad()
    let button = UIButton(type:UIButton.ButtonType.custom)
    button.addTarget(self, action: #selector(handleButtonAction), for: .touchUpInside)
    button.setTitle("Press me", for: UIControl.State.normal)
    button.frame = CGRect(x: 80.0, y: 210.0, width: 160.0, height: 40.0)
    button.backgroundColor = UIColor.blue
    self.view.addSubview(button)
  }

  @objc func handleButtonAction() {
    if let flutterEngine = (UIApplication.shared.delegate as? AppDelegate)?.flutterEngine {
      let flutterViewController = FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil)
      self.present(flutterViewController, animated: false, completion: nil)
    }
  }
}
```

现在，您应该能够在模拟器或设备上构建并启动MyApp。按下按钮应使用标准Flutter Demo计数应用程序调出全屏Flutter视图。您可以使用路线在应用程序的不同位置显示不同的小部件，如上面的Android部分所述。要设置路线，请致电

- 目标C：

```objective-c
[flutterViewController setInitialRoute:@"route1"];
```

- 迅速：

```swift
flutterViewController.setInitialRoute("route1")
```

在构建之后`FlutterViewController`（并在展示之前）。

您可以通过调用`SystemNavigator.pop()` Dart代码让Flutter应用自行关闭。

### 生成并运行您的应用

您使用Xcode构建和运行MyApp的方式与添加Flutter模块依赖项之前的方式完全相同。编辑，调试和分析iOS代码也是如此。

### 热重启/重新加载和调试Dart代码

连接设备或启动模拟器。然后使Flutter CLI工具监听您的应用程序：

```sh
$ cd some/path/my_flutter
$ flutter attach
Waiting for a connection from Flutter on iPhone X...
```

`MyApp`从Xcode以调试模式启动。导航到使用Flutter的应用程序区域。然后回到终端，您应该看到类似于以下内容的输出：

```
Done.
Syncing files to device iPhone X...                          4.7s

🔥  To hot reload changes while running, press "r". To hot restart (and rebuild state), press "R".
An Observatory debugger and profiler on iPhone X is available at: http://127.0.0.1:54741/
For a more detailed help message, press "h". To quit, press "q".
```

现在，您可以在中编辑Dart代码`my_flutter`，并且可以通过`r`在终端中按来重新加载更改。您也可以将上面的URL粘贴到浏览器中，以使用Dart Observatory设置断点，分析内存保留和其他调试任务。

#### 调试Flutter的特定实例

可以向`root isolates`应用程序添加Flutter（）的多个实例。`flutter attach`默认情况下连接到所有可用的隔离。然后，将从附加的CLI发送的所有命令转发到每个附加的隔离。

通过`l`从附加的`flutter`CLI工具中键入，列出所有附加的隔离株。如果未指定，将从dart入口点文件和函数名称自动生成隔离名称。

`l`同时显示两个Flutter隔离的应用程序的示例输出：

```
Connected views:
  main.dart$main-517591213 (isolates/517591213)
  main.dart$main-332962855 (isolates/332962855)
```

分两步附加到特定的隔离株：

1. 在Dart来源中命名感兴趣的Flutter根分离株。

```dart
// main.dart
import 'dart:ui' as ui;

void main() {
  ui.window.setIsolateDebugName("debug isolate");
  // ...
}
```

1. `flutter attach`使用该`--isolate-filter`选项运行。

```sh
$ flutter attach --isolate-filter='debug'
Waiting for a connection from Flutter...
Done.
Syncing files to device...      1.1s

🔥  To hot reload changes while running, press "r". To hot restart (and rebuild state), press "R".
An Observatory debugger and profiler is available at: http://127.0.0.1:43343/
For a more detailed help message, press "h". To detach, press "d"; to quit, press "q".

Connected view:
  debug isolate (isolates/642101161)
```

您可以查看[`93573de`](https://github.com/flutter/flutter/commit/93573de2165c750fdeefcd2d620e2b8bd494fed6)更详细的示例。



--------
引用自[GitHub Flutter Wiki](https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps)
